# Импортируем модуль для работы с регулярными выражениями
import re


# ============ ЗАДАНИЕ 1: Валидация логина ============
def validate_login(login):
    """
    Проверяет, правильный ли логин

    Правила:
    - Начинается с буквы
    - Только латиница, цифры и _
    - Длина от 5 до 20 символов
    - Не заканчивается на _

    login: строка для проверки
    return: True если логин правильный, False если нет
    """

    # Паттерн для проверки логина
    # ^ - начало строки
    # [a-zA-Z] - первая буква (латиница)
    # [a-zA-Z0-9_]{4,19} - следующие символы (4-19 штук): буквы, цифры или _
    # $ - конец строки
    # Получается всего от 5 до 20 символов (первый + 4-19)
    pattern = r'^[a-zA-Z][a-zA-Z0-9_]{4,19}$'

    # Проверяем, заканчивается ли логин на _
    if login.endswith('_'):
        return False

    # Проверяем, соответствует ли логин паттерну
    # re.fullmatch - проверяет, что ВСЯ строка соответствует паттерну
    if re.fullmatch(pattern, login):
        return True
    else:
        return False


# ============ ЗАДАНИЕ 2: Поиск дат в тексте ============
def find_dates(text):
    """
    Находит все даты в тексте

    Форматы дат:
    - DD.MM.YYYY
    - DD-MM-YYYY
    - DD/MM/YYYY

    text: текст для поиска
    return: список найденных дат
    """

    # Паттерн для поиска дат
    # \b - граница слова (чтобы не найти часть другого слова)
    # \d{1,2} - 1 или 2 цифры (день)
    # [\./-] - разделитель: точка, дефис или слеш
    # \d{1,2} - 1 или 2 цифры (месяц)
    # [\./-] - разделитель
    # \d{2,4} - 2 или 4 цифры (год)
    # \b - граница слова
    pattern = r'\b\d{1,2}[\./-]\d{1,2}[\./-]\d{2,4}\b'

    # re.findall - находит ВСЕ совпадения в тексте
    # Возвращает список строк, которые подходят под паттерн
    dates = re.findall(pattern, text)

    return dates


# ============ ЗАДАНИЕ 3: Парсинг логов ============
def parse_log(log_line):
    """
    Разбирает строку лога на части

    Формат: "2024-02-10 14:23:01 INFO user=ada action=login ip=192.168.1.15"

    log_line: строка лога
    return: словарь с разобранными данными
    """

    # Сначала разбираем основную часть (дата, время, уровень, остальное)
    # ^ - начало строки
    # (\d{4}-\d{2}-\d{2}) - группа 1: дата (год-месяц-день)
    # \s+ - один или больше пробелов
    # (\d{2}:\d{2}:\d{2}) - группа 2: время (часы:минуты:секунды)
    # \s+ - пробелы
    # (\w+) - группа 3: уровень (буквы)
    # \s+ - пробелы
    # (.+)$ - группа 4: все остальное до конца строки
    main_pattern = r'^(\d{4}-\d{2}-\d{2})\s+(\d{2}:\d{2}:\d{2})\s+(\w+)\s+(.+)$'

    # Пытаемся найти совпадение
    match = re.search(main_pattern, log_line)

    # Если ничего не нашли, возвращаем пустой словарь
    if not match:
        return {}

    # Забираем найденные группы
    date = match.group(1)  # дата
    time = match.group(2)  # время
    level = match.group(3)  # уровень
    params_str = match.group(4)  # строка с параметрами

    # Теперь разбираем параметры вида "ключ=значение"
    # (\w+) - группа 1: ключ (буквы)
    # = - знак равно
    # ([^\s]+) - группа 2: значение (все до пробела)
    params_pattern = r'(\w+)=([^\s]+)'

    # Находим все пары ключ=значение
    params_matches = re.findall(params_pattern, params_str)

    # Создаем словарь для результата
    result = {
        'date': date,
        'time': time,
        'level': level
    }

    # Добавляем все найденные параметры в результат
    for key, value in params_matches:
        result[key] = value

    return result


# ============ ЗАДАНИЕ 4: Проверка пароля ============
def validate_password(password):
    """
    Проверяет, надежный ли пароль

    Правила:
    - Минимум 8 символов
    - Хотя бы одна заглавная буква
    - Хотя бы одна строчная буква
    - Хотя бы одна цифра
    - Хотя бы один спецсимвол !@#$%^&*

    password: строка для проверки
    return: True если пароль надежный, False если нет
    """

    # Проверяем длину
    if len(password) < 8:
        return False

    # Проверяем наличие заглавных букв (A-Z)
    # re.search - ищет хоть одно совпадение в любом месте
    has_upper = bool(re.search(r'[A-Z]', password))

    # Проверяем наличие строчных букв (a-z)
    has_lower = bool(re.search(r'[a-z]', password))

    # Проверяем наличие цифр (0-9)
    has_digit = bool(re.search(r'\d', password))

    # Проверяем наличие спецсимволов
    has_special = bool(re.search(r'[!@#$%^&*]', password))

    # Возвращаем True только если ВСЕ проверки пройдены
    return has_upper and has_lower and has_digit and has_special


# ============ ЗАДАНИЕ 5: E-mail с ограниченными доменами ============
def validate_email_domain(email, domains):
    """
    Проверяет email и разрешен ли его домен

    email: адрес для проверки
    domains: список разрешенных доменов
    return: True если email правильный и домен разрешен, False если нет
    """

    # Простой паттерн для email
    # [a-zA-Z0-9._%+-]+ - имя пользователя (буквы, цифры, и некоторые символы)
    # @ - собачка
    # [a-zA-Z0-9-]+ - домен (буквы, цифры, точки, дефисы)
    # \. - точка
    # [a-zA-Z]{2,} - доменная зона (от 2 букв)
    email_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9-]+\.[a-zA-Z]{2,}$'

    # Проверяем формат email
    if not re.fullmatch(email_pattern, email):
        return False

    # Получаем домен из email (часть после @)
    # split('@') разбивает строку на две части: до @ и после @
    # [1] берем вторую часть (после @)
    domain = email.split('@')[1]

    # Проверяем, есть ли домен в списке разрешенных
    if domain in domains:
        return True
    else:
        return False


# ============ ЗАДАНИЕ 6: Нормализация телефонных номеров ============
def normalize_phone(phone):
    """
    Приводит номер телефона к единому формату +79991234567

    phone: номер в любом формате
    return: номер в формате +7 и 10 цифр
    """

    # Убираем все символы, кроме цифр
    # \D - любой НЕ цифровой символ
    # re.sub - заменяет все НЕ цифры на пустую строку
    digits_only = re.sub(r'\D', '', phone)

    # Если номер начинался с +, то в начале была цифра
    # Проверяем, был ли в исходном номере +
    if phone.startswith('+'):
        # Если номер уже в формате +7...
        if len(digits_only) == 11:  # 7XXXXXXXXXX (11 цифр)
            return '+' + digits_only
    else:
        # Обрабатываем разные форматы
        if len(digits_only) == 11:  # 8XXXXXXXXXX или 7XXXXXXXXXX
            # Если начинается с 8, меняем на 7
            if digits_only.startswith('8'):
                return '+7' + digits_only[1:]
            # Если начинается с 7, просто добавляем +
            elif digits_only.startswith('7'):
                return '+' + digits_only
        elif len(digits_only) == 10:  # XXXXXXXXXX (без кода страны)
            return '+7' + digits_only

    # Если формат не подходит, возвращаем как есть
    return phone
# ============ ПРОСТАЯ ПРОВЕРКА РАБОТЫ ============

print("=" * 50)
print("ПРОВЕРКА РАБОТЫ ФУНКЦИЙ")
print("=" * 50)

# Задание 1: Проверка логина
print("\n1. Проверка логина:")
print("user123 ->", validate_login("user123"))  # Должно быть True
print("123user ->", validate_login("123user"))  # Должно быть False
print("user_ ->", validate_login("user_"))  # Должно быть False

# Задание 2: Поиск дат
print("\n2. Поиск дат:")
text = "Сегодня 15.03.2024, завтра 16-03-24, вчера 14/03/2024"
print("Текст:", text)
print("Найденные даты:", find_dates(text))

# Задание 3: Парсинг логов
print("\n3. Парсинг лога:")
log = "2024-02-10 14:23:01 INFO user=ada action=login ip=192.168.1.15"
print("Лог:", log)
print("Результат:", parse_log(log))

# Задание 4: Проверка пароля
print("\n4. Проверка пароля:")
print("Pass123! ->", validate_password("Pass123!"))  # True
print("password ->", validate_password("password"))  # False

# Задание 5: Проверка email
print("\n5. Проверка email:")
domains = ['gmail.com', 'yandex.ru', 'edu.ru']
print("Разрешенные домены:", domains)
print("user@gmail.com ->", validate_email_domain("user@gmail.com", domains))  # True
print("user@mail.ru ->", validate_email_domain("user@mail.ru", domains))  # False

# Задание 6: Нормализация телефона
print("\n6. Нормализация телефона:")
phones = [
    "8 (999) 123-45-67",
    "+7 999 123 45 67",
    "89991234567",
    "9991234567"
]
for phone in phones:
    print(f"{phone} -> {normalize_phone(phone)}")
